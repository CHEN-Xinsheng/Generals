\section{遇到的困难及解决}

\subsection{初始棋盘信息不正确的问题}
一开始初始棋盘写成 MIF 文件，存在RAM里，用 ip 核读取。但少数情况下读取的少部分数据有问题，猜测可能是 RAM 内存在“噪点”或其它异常。将初始棋盘改成直接用 \texttt{localparam} 写在程序里（打表），可以正常加载初始棋盘。

\subsection{SV 语言特性}
\subsubsection{时序逻辑块中的寄存器赋值问题}

一个寄存器在一个 \texttt{always\_ff} 块中只能赋值一次。如果有多次赋值，那么除最后一个赋值语句之外的语句都将被覆盖。

对于本游戏，在每一回合结束时，既需要结算玩家操作引起的兵力变化，又需要结算兵力的自然增长。为了避免实现代码过于复杂且混乱，我们将这两个部分分离，具体而言即增加 \texttt{ROUND\_SWITCH} 状态，用于结算兵力的自然增长，将两部分兵力变化分开在两个周期内进行。这样同时也让代码的模块化更佳。

\subsubsection{组合逻辑块中的赋值问题}
每个 \texttt{always\_comb}块必须覆盖 \texttt{if} 的所有情况，同时在每种情况下都为变量赋值，否则无法编译。这与平时软件语言的惯例不同，曾导致花费了大量时间来找编译不通过的问题

\subsubsection{运算符语法问题}
Verilog 具有自己的运算语法，尤其是运算符优先级的问题，如移位运算在加法运算之后，这一度导致我们无法正确读取棋盘数据（因为地址运算错误），在查询资料后修改解决。

\subsection{时序问题}
初期，我们选用50MHz时钟用于 $800\times600@75 \, \text{Hz}
$ VGA 显示，100MHz时钟用于游戏内部逻辑运算，发现在早期没有太多逻辑运算时可以维持，但只要增加逻辑就会发生时序报错，画面无法正常渲染。为了避免时序要求不满足的问题，我们采取了两个措施：

\textcircled{1}内部逻辑提速：考虑到复杂性问题，我们将所有的除法（包括取模）和部分乘法用打表实现，这在初期显著提高了性能。

\textcircled{2}更换时钟：在逻辑运算大量增加后，我们意识到原有的时钟频率不能支持这个规模的运算，决定更改时钟，同时修改VGA以适配，选用25MHz时钟用于 $640\times480@60 \, \text{Hz}
$ VGA 显示，50MHz时钟用于游戏内部逻辑运算。调整后，项目时序报错问题得到解决，运行时具有较高的稳定性。